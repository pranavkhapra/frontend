{"ast":null,"code":"function paginate(totalItems, currentPage = 1, pageSize = 10, maxPages = 10) {\n  // calculate total pages\n  let totalPages = Math.ceil(totalItems / pageSize); // ensure current page isn't out of range\n\n  if (currentPage < 1) {\n    currentPage = 1;\n  } else if (currentPage > totalPages) {\n    currentPage = totalPages;\n  }\n\n  let startPage, endPage;\n\n  if (totalPages <= maxPages) {\n    // total pages less than max so show all pages\n    startPage = 1;\n    endPage = totalPages;\n  } else {\n    // total pages more than max so calculate start and end pages\n    let maxPagesBeforeCurrentPage = Math.floor(maxPages / 2);\n    let maxPagesAfterCurrentPage = Math.ceil(maxPages / 2) - 1;\n\n    if (currentPage <= maxPagesBeforeCurrentPage) {\n      // current page near the start\n      startPage = 1;\n      endPage = maxPages;\n    } else if (currentPage + maxPagesAfterCurrentPage >= totalPages) {\n      // current page near the end\n      startPage = totalPages - maxPages + 1;\n      endPage = totalPages;\n    } else {\n      // current page somewhere in the middle\n      startPage = currentPage - maxPagesBeforeCurrentPage;\n      endPage = currentPage + maxPagesAfterCurrentPage;\n    }\n  } // calculate start and end item indexes\n\n\n  let startIndex = (currentPage - 1) * pageSize;\n  let endIndex = Math.min(startIndex + pageSize - 1, totalItems - 1); // create an array of pages to ng-repeat in the pager control\n\n  let pages = Array.from(Array(endPage + 1 - startPage).keys()).map(i => startPage + i); // return object with all pager properties required by the view\n\n  return {\n    totalItems: totalItems,\n    currentPage: currentPage,\n    pageSize: pageSize,\n    totalPages: totalPages,\n    startPage: startPage,\n    endPage: endPage,\n    startIndex: startIndex,\n    endIndex: endIndex,\n    pages: pages\n  };\n}\n\nexport default paginate;","map":{"version":3,"sources":["/home/just_a_random_person_to_ignore/React-JS-Student-Management-System-Frontend/src/utils/paginate.js"],"names":["paginate","totalItems","currentPage","pageSize","maxPages","totalPages","Math","ceil","startPage","endPage","maxPagesBeforeCurrentPage","floor","maxPagesAfterCurrentPage","startIndex","endIndex","min","pages","Array","from","keys","map","i"],"mappings":"AAAA,SAASA,QAAT,CACIC,UADJ,EAEIC,WAAW,GAAG,CAFlB,EAGIC,QAAQ,GAAG,EAHf,EAIIC,QAAQ,GAAG,EAJf,EAKE;AACE;AACA,MAAIC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUN,UAAU,GAAGE,QAAvB,CAAjB,CAFF,CAIE;;AACA,MAAID,WAAW,GAAG,CAAlB,EAAqB;AACjBA,IAAAA,WAAW,GAAG,CAAd;AACH,GAFD,MAEO,IAAIA,WAAW,GAAGG,UAAlB,EAA8B;AACjCH,IAAAA,WAAW,GAAGG,UAAd;AACH;;AAED,MAAIG,SAAJ,EAAeC,OAAf;;AACA,MAAIJ,UAAU,IAAID,QAAlB,EAA4B;AACxB;AACAI,IAAAA,SAAS,GAAG,CAAZ;AACAC,IAAAA,OAAO,GAAGJ,UAAV;AACH,GAJD,MAIO;AACH;AACA,QAAIK,yBAAyB,GAAGJ,IAAI,CAACK,KAAL,CAAWP,QAAQ,GAAG,CAAtB,CAAhC;AACA,QAAIQ,wBAAwB,GAAGN,IAAI,CAACC,IAAL,CAAUH,QAAQ,GAAG,CAArB,IAA0B,CAAzD;;AACA,QAAIF,WAAW,IAAIQ,yBAAnB,EAA8C;AAC1C;AACAF,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,OAAO,GAAGL,QAAV;AACH,KAJD,MAIO,IAAIF,WAAW,GAAGU,wBAAd,IAA0CP,UAA9C,EAA0D;AAC7D;AACAG,MAAAA,SAAS,GAAGH,UAAU,GAAGD,QAAb,GAAwB,CAApC;AACAK,MAAAA,OAAO,GAAGJ,UAAV;AACH,KAJM,MAIA;AACH;AACAG,MAAAA,SAAS,GAAGN,WAAW,GAAGQ,yBAA1B;AACAD,MAAAA,OAAO,GAAGP,WAAW,GAAGU,wBAAxB;AACH;AACJ,GAjCH,CAmCE;;;AACA,MAAIC,UAAU,GAAG,CAACX,WAAW,GAAG,CAAf,IAAoBC,QAArC;AACA,MAAIW,QAAQ,GAAGR,IAAI,CAACS,GAAL,CAASF,UAAU,GAAGV,QAAb,GAAwB,CAAjC,EAAoCF,UAAU,GAAG,CAAjD,CAAf,CArCF,CAuCE;;AACA,MAAIe,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAAER,OAAO,GAAG,CAAX,GAAgBD,SAAjB,CAAL,CAAiCW,IAAjC,EAAX,EAAoDC,GAApD,CAAwDC,CAAC,IAAIb,SAAS,GAAGa,CAAzE,CAAZ,CAxCF,CA0CE;;AACA,SAAO;AACHpB,IAAAA,UAAU,EAAEA,UADT;AAEHC,IAAAA,WAAW,EAAEA,WAFV;AAGHC,IAAAA,QAAQ,EAAEA,QAHP;AAIHE,IAAAA,UAAU,EAAEA,UAJT;AAKHG,IAAAA,SAAS,EAAEA,SALR;AAMHC,IAAAA,OAAO,EAAEA,OANN;AAOHI,IAAAA,UAAU,EAAEA,UAPT;AAQHC,IAAAA,QAAQ,EAAEA,QARP;AASHE,IAAAA,KAAK,EAAEA;AATJ,GAAP;AAWH;;AAED,eAAehB,QAAf","sourcesContent":["function paginate(\n    totalItems,\n    currentPage = 1,\n    pageSize = 10,\n    maxPages = 10\n) {\n    // calculate total pages\n    let totalPages = Math.ceil(totalItems / pageSize);\n\n    // ensure current page isn't out of range\n    if (currentPage < 1) {\n        currentPage = 1;\n    } else if (currentPage > totalPages) {\n        currentPage = totalPages;\n    }\n\n    let startPage, endPage;\n    if (totalPages <= maxPages) {\n        // total pages less than max so show all pages\n        startPage = 1;\n        endPage = totalPages;\n    } else {\n        // total pages more than max so calculate start and end pages\n        let maxPagesBeforeCurrentPage = Math.floor(maxPages / 2);\n        let maxPagesAfterCurrentPage = Math.ceil(maxPages / 2) - 1;\n        if (currentPage <= maxPagesBeforeCurrentPage) {\n            // current page near the start\n            startPage = 1;\n            endPage = maxPages;\n        } else if (currentPage + maxPagesAfterCurrentPage >= totalPages) {\n            // current page near the end\n            startPage = totalPages - maxPages + 1;\n            endPage = totalPages;\n        } else {\n            // current page somewhere in the middle\n            startPage = currentPage - maxPagesBeforeCurrentPage;\n            endPage = currentPage + maxPagesAfterCurrentPage;\n        }\n    }\n\n    // calculate start and end item indexes\n    let startIndex = (currentPage - 1) * pageSize;\n    let endIndex = Math.min(startIndex + pageSize - 1, totalItems - 1);\n\n    // create an array of pages to ng-repeat in the pager control\n    let pages = Array.from(Array((endPage + 1) - startPage).keys()).map(i => startPage + i);\n\n    // return object with all pager properties required by the view\n    return {\n        totalItems: totalItems,\n        currentPage: currentPage,\n        pageSize: pageSize,\n        totalPages: totalPages,\n        startPage: startPage,\n        endPage: endPage,\n        startIndex: startIndex,\n        endIndex: endIndex,\n        pages: pages\n    };\n}\n\nexport default paginate;"]},"metadata":{},"sourceType":"module"}